Starting program: /nfs/stak/users/guom/CS362-W2019/projects/guom/mccallcoDominion/cardtest4 

Breakpoint 1, main (argc=1, argv=0x7fffffffe158) at cardtest4.c:28
28		buyCard(adventurer, &Game);
buyCard (supplyPos=7, state=0x7fffffff7990) at dominion.c:419
419	  who = state->whoseTurn;
421	  if (state->numBuys < 1){
425	  } else if (supplyCount(supplyPos, state) <1){
supplyCount (card=7, state=0x7fffffff7990) at dominion.c:460
460	  return state->supplyCount[card];
461	}
buyCard (supplyPos=7, state=0x7fffffff7990) at dominion.c:429
429	  } else if (state->coins < getCost(supplyPos)){
getCost (cardNumber=7) at dominion.c:724
724	  switch( cardNumber ) 
741	      return 6;
783	}
buyCard (supplyPos=7, state=0x7fffffff7990) at dominion.c:434
434	    state->phase=1;
436	    gainCard(supplyPos, state, 2, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
gainCard (supplyPos=7, state=0x7fffffff7990, toFlag=2, player=0)
    at dominion.c:1290
1290	  if ( supplyCount(supplyPos, state) < 1 )
supplyCount (card=7, state=0x7fffffff7990) at dominion.c:460
460	  return state->supplyCount[card];
461	}
gainCard (supplyPos=7, state=0x7fffffff7990, toFlag=2, player=0)
    at dominion.c:1300
1300	  if (toFlag == 1)
1305	  else if (toFlag == 2)
1307	      state->hand[ player ][ state->handCount[player] ] = supplyPos;
1308	      state->handCount[player]++;
1317	  state->supplyCount[supplyPos]--;
1319	  return 0;
1320	}
buyCard (supplyPos=7, state=0x7fffffff7990) at dominion.c:438
438	    state->coins = (state->coins) - (getCost(supplyPos));
getCost (cardNumber=7) at dominion.c:724
724	  switch( cardNumber ) 
741	      return 6;
783	}
buyCard (supplyPos=7, state=0x7fffffff7990) at dominion.c:439
439	    state->numBuys--;
Hardware watchpoint 3: state->numBuys
Hardware watchpoint 3: state->numBuys

Old value = 1
New value = 0
buyCard (supplyPos=7, state=0x7fffffff7990) at dominion.c:447
447	  return 0;
Continuing.

Watchpoint 3 deleted because the program has left the block in
which its expression is valid.
main (argc=1, argv=0x7fffffffe158) at cardtest4.c:30
30		for(int i = 0; i < numHandCards(&Game); i++){
numHandCards (state=0x7fffffff7990) at dominion.c:451
451	  return state->handCount[ whoseTurn(state) ];
Continuing.

Breakpoint 2, main (argc=1, argv=0x7fffffffe158) at cardtest4.c:61
61		Game.phase = 0;
62		playCard(adventurerPos, -1, -1, -1, &Game);
playCard (handPos=5, choice1=-1, choice2=-1, choice3=-1, state=0x7fffffff7990)
    at dominion.c:373
373	  int coin_bonus = 0; 		//tracks coins gain from actions
376	  if (state->phase != 0)
382	  if ( state->numActions < 1 )
388	  card = handCard(handPos, state);
391	  if ( card < adventurer || card > treasure_map )
397	  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
cardEffect (card=7, choice1=-1, choice2=-1, choice3=-1, state=0x7fffffff7990, 
    handPos=5, bonus=0x7fffffff7938) at dominion.c:791
791	  int currentPlayer = whoseTurn(state);
whoseTurn (state=0x7fffffff7990) at dominion.c:486
486	  return state->whoseTurn;
487	}
cardEffect (card=7, choice1=-1, choice2=-1, choice3=-1, state=0x7fffffff7990, 
    handPos=5, bonus=0x7fffffff7938) at dominion.c:792
792	  int nextPlayer = currentPlayer + 1;
794	  int tributeRevealedCards[2] = {-1, -1};
796	  int drawntreasure=0;
797	  int z = 0;// this is the counter for the temp hand
798	  if (nextPlayer > (state->numPlayers - 1)){
804	  switch( card ) 
807	      switchAdventurer(state, currentPlayer, temphand, &drawntreasure, z);
switchAdventurer (state=0x7fffffff7990, currentPlayer=0, 
    temphand=0x7fffffff70f0, drawntreasure=0x7fffffff70ec, z=0)
    at dominion.c:10
10	  while(*drawntreasure<2){
11		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
14		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7990) at dominion.c:667
667	  if (state->deckCount[player] <= 0){//Deck is empty
707	    int count = state->handCount[player];//Get current hand count for player
713	    deckCounter = state->deckCount[player];//Create holder for the deck count
714	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
715	    state->deckCount[player]--;
716	    state->handCount[player]++;//Increment hand count
Hardware watchpoint 4: state->handCount[player]
Hardware watchpoint 4: state->handCount[player]

Old value = 6
New value = 7
0x0000000000403ecb in drawCard (player=0, state=0x7fffffff7990)
    at dominion.c:716
716	    state->handCount[player]++;//Increment hand count
719	  return 0;
720	}

Watchpoint 4 deleted because the program has left the block in
which its expression is valid.
switchAdventurer (state=0x7fffffff7990, currentPlayer=0, 
    temphand=0x7fffffff70f0, drawntreasure=0x7fffffff70ec, z=0)
    at dominion.c:15
15		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
16		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
17		  (*drawntreasure)++;
10	  while(*drawntreasure<2){
11		if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
14		drawCard(currentPlayer, state);
drawCard (player=0, state=0x7fffffff7990) at dominion.c:667
667	  if (state->deckCount[player] <= 0){//Deck is empty
707	    int count = state->handCount[player];//Get current hand count for player
713	    deckCounter = state->deckCount[player];//Create holder for the deck count
714	    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
715	    state->deckCount[player]--;
716	    state->handCount[player]++;//Increment hand count
Hardware watchpoint 5: state->handCount[player]
Hardware watchpoint 5: state->handCount[player]

Old value = 7
New value = 8
0x0000000000403ecb in drawCard (player=0, state=0x7fffffff7990)
    at dominion.c:716
716	    state->handCount[player]++;//Increment hand count
719	  return 0;
720	}

Watchpoint 5 deleted because the program has left the block in
which its expression is valid.
switchAdventurer (state=0x7fffffff7990, currentPlayer=0, 
    temphand=0x7fffffff70f0, drawntreasure=0x7fffffff70ec, z=0)
    at dominion.c:15
15		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
16		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
17		  (*drawntreasure)++;
10	  while(*drawntreasure<2){
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
26		z=z-1;
27	      }
25		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
A debugging session is active.

	Inferior 1 [process 4359] will be killed.

Quit anyway? (y or n) 